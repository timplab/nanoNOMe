---
title: "nanoNOMe single-read combinatorial clutsering"
author: "Isac Lee"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_notebook: default
  pdf_document: default
mainfont: DejaVu Sans
titlefont: DejaVu Sans
---

```{r setup, eval=TRUE, include=FALSE, cache=F, message=F, warning=F, results="hide"}
rm(list=ls());gc()
knitr::opts_chunk$set(fig.path='figs/')
knitr::opts_chunk$set(cache = FALSE, warning = FALSE,
                      message = FALSE, cache.lazy = FALSE)
my_plot_hook <- function(x, options)
  paste("\n", knitr::hook_plot_tex(x, options), "\n")
knitr::knit_hooks$set(plot = my_plot_hook)
```

```{r libs, eval=T, include=FALSE, cache=F, message=F, warning=F, results="hide"}
source("/home/isac/Code/ilee/plot/ilee_plot_utils.R")
library(parallel)
library("ggsci")
source("~/Code/nanopore-methylation-utilities/methylation_R_utils.R")
library(bsseq)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
db <- TxDb.Hsapiens.UCSC.hg38.knownGene
library(biomaRt)
library(BPRMeth)
library(ggridges)
library(mclust)
library(ggridges)
library(BSgenome.Hsapiens.UCSC.hg38)

```

```{r functions, include = F}
fix_protein_runs <- function(gcruns,mod){
  # first split by value
  gcruns_closed <- gcruns %>%
    filter(values == 0)
  gcruns_open <- gcruns %>%
    filter(values == 1)
  # predict using mod and get the probability of the run being in 1st cluster
  prot_prob <- predict(mod,gcruns_closed$width)$z[,1]
  # replace protein-bound calls with a open calls
  gcruns_closed$values[which(prot_prob > 0.5)] <- 1
  # recombine 
  bind_rows(gcruns_open,gcruns_closed)
}

```
```{r paths, eval = T, include = FALSE, cache=F }
nanonomedir <- "/uru/Data/Nanopore/projects/nanonome/pooled"
subdir <- file.path(nanonomedir,"../regs")
plotdir <- "~/Dropbox/Data/nome-seq/version3_guppy3/plots/readlevel"
cpg_fp <- file.path(nanonomedir,"mfreq/GM12878_nanoNOMe.cpg.mfreq.txt.gz")
gpc_fp <- file.path(nanonomedir,"mfreq/GM12878_nanoNOMe.gpc.mfreq.txt.gz")
cpg_bs_fp <- file.path(nanonomedir,"mfreq/GM12878_nanoNOMe.cpg.BSseq.rds")
gpc_bs_fp <- file.path(nanonomedir,"mfreq/GM12878_nanoNOMe.gpc.BSseq.rds")
# mbed
mbed_path <- file.path(nanonomedir,"GM12878_nanoNOMe.cpggpc.meth.bed.gz")
```

```{r annotation, eval = T, include = FALSE, cache=F }
# expression data
genes_fp <- "/kyber/Data/Nanopore/projects/nanonome/analysis/data/gm12878/GM12878_genes_exp_quartiles.bed"
cnames <- c("chrom","start","end","txid","quartile","strand","ensid","hgnc_symbol","fpkm")
genes <- read_tsv(genes_fp,col_names = cnames)

tss <- genes %>%
  mutate(start = ifelse(strand=="-",end, start), end = start)

# motif numbers
# get 200 bp GpC number
tss.gr <- GRanges(tss)
seqregs.gr <- resize(tss.gr,width = 200, fix = "center")
# get sequence
regs.seq <- getSeq(Hsapiens,seqregs.gr)
gclist <- gregexpr2("GC",regs.seq)
gcnums <- sapply(gclist,length)
tss$gcnum <- gcnums

seqregs.gr <- resize(tss.gr,width = 1000, fix = "center")
# get sequence
regs.seq <- getSeq(Hsapiens,seqregs.gr)
cglist <- gregexpr2("CG",regs.seq)
cgnums <- sapply(cglist,length)
tss$cgnum <- cgnums

# Let's look at 1kb around
width <- 1e3
side <- width/2
# bed format
regs.sub <- tss %>%
  mutate(start = start - side - 1, 
         end = end + side + 1) %>%
  filter(start >=0) %>%
  arrange(chrom,start,end)  %>%
  dplyr::select(-fpkm)

```

```{r gcdensity_plot, eval = T, echo = F, fig.height=3, fig.width=4, message=F, warning = F,results = 'hide', fig.show = 'show'}
# https://stackoverflow.com/questions/34029811/fill-different-colors-for-each-quantile-in-geom-density-of-ggplot
qs <- quantile(regs.sub$gcnum,c(0.25,0.5,0.75,1))
dens <- density(regs.sub$gcnum)
dens.plt <- tibble(x = dens$x, y = dens$y) %>%
  mutate(Percentile = factor(findInterval(x,qs)))
plotpath <- file.path(plotdir,"200731_tss_gcdensity_distro.pdf")
pdf(plotpath,height = 2, width = 4)
ggplot(dens.plt,aes( x = x,y = y)) +
  geom_line() + 
  geom_ribbon(aes(ymin = 0,ymax = y,fill = Percentile)) +
  scale_x_continuous(breaks = qs, labels = qs) +
  scale_fill_brewer(labels = names(qs) ) +
  theme(axis.text.x = element_text(angle = 45,hjust = 1)) +
  labs( x = "Number of GpC Motifs in 200 bp Region Around TSS", y = "Density Across All TSS")
dev.off()
```

```{r regs, eval = T, include = FALSE, cache=F }
# Read or write regions
regs.fp <- file.path(subdir,"200113_GM12878.tss_prom_1kb.all.bed")
#regs.fp <- file.path(subdir,"121223_GM12878.tss_prom_1000_per_exp.bed")
if (file.exists(regs.fp)) {
  message("reading regions")
  regs.sub <- read_tsv(regs.fp, col_names = c("chrom","start","end","txid","exp","strand","ensid","hgnc","gcnum"))
} else {
  message("writing regions")
  write_tsv(regs.sub, regs.fp,col_names = F)
}

```

# single-read

```{r single_read_region, eval = T, include = FALSE, cache=F }
sub.fp = file.path(subdir,"GM12878_nanoNOMe.tss_singleread.1kb.all.cpggpc.meth.bed")
env.list <- list(
  bed = regs.fp,
  sub = sub.fp
)
do.call(Sys.setenv,env.list)

```

# subset mbed - use bedtools to require full intersection with the 1kb region
```{r subset_mbed}
mbed <- "/uru/Data/Nanopore/projects/nanonome/pooled/mbed/GM12878_nanoNOMe.cpggpc.meth.bed.gz"
com <- paste("bedtools intersect -F 1 -sorted -u -a",mbed,"-b",regs.fp,">",sub.fp)
print(com)
system(com)
```

load single-read data

```{r single_read, eval = T, include = FALSE, cache=F }
# fetch single read data in this region
reads <- tabix_mbed(sub.fp,extcol = "motif",by = "read")
# separate by mod
reads.cpg <- reads[reads$motif == "CG",]
reads.gpc <- reads[reads$motif == "GC",]
# remove fully methylated gpc reads
reads.gpc <- remove_fully_methylated(reads.gpc)
```

# get calls, smooth gc, and add distance

```{r single_read_parse, eval = T, include = FALSE, cache=F }
# do cg and gc separately and use mclapply
# no mclapply b/c it uses too much ram for the amount of data I'm tryying to handle
# It will take forever to run, so I'll just run overnight
st <- Sys.time()
cgcalls <- bind_rows(mclapply(mc.cores = 2,seq(nrow(regs.sub)),function(i){
  print(i)
  reg <- regs.sub[i,]
  callreg <- regs.sub[i,]
  reginfo <- reg %>% 
    dplyr::rename(regstart = start, regend = end) %>%
    dplyr::select( - chrom) 
  # subset reads overlapping this region
  cg.reg <- reads.cpg %>%
    filter(chrom == reg$chrom, start <= reg$start, end >= reg$end)
  calls <- tibble()
  if (nrow(cg.reg) != 0) {
    # fix calls
    calls <- mbedByCall(cg.reg,region = callreg, verbose = F) %>%
      redo_mcall(1.5) 
    # add info and label, get distance
    calls <- calls %>%
      bind_cols(reginfo[rep(1,nrow(calls)),]) 
  }
  calls
})) 
cgcalls <- cgcalls %>%
  mutate(
    center = (regstart + regend)/2,
    distance = ifelse(strand == "-",center - start,start - center))
Sys.time() - st

# for gc, let's do all the way to runs
st <- Sys.time()
gcruns <- bind_rows(mclapply(mc.cores = 2,seq(nrow(regs.sub)),function(i){
  print(i)
  reg <- regs.sub[i,]
  # subset reads overlapping this region
  gc.reg <- reads.gpc %>%
    filter(chrom == reg$chrom, start <= reg$start, end >= reg$end)
  runs <- tibble()
  if (nrow(gc.reg) != 0) {
    callreg <- regs.sub[i,]
    reginfo <- reg %>% 
      dplyr::rename(regstart = start, regend = end) %>%
      dplyr::select( -chrom)
    # fix calls
    gccalls <- mbedByCall(gc.reg,verbose = F) %>%
      redo_mcall(1) 
    # smooth
    calls.reg <- gccalls %>%
      group_by(qname)
    calls.list <- calls.reg %>% 
      group_split(keep = T)
    smooth.list <- lapply(calls.list,smoothCalls,reg = callreg)
    calls.smooth <- bind_rows(smooth.list)
    # add info and label, get distance
    runs <- getRuns_fast(calls.smooth) 
    runs <- runs %>%
      bind_cols(reginfo[rep(1,nrow(runs)),]) 
  } 
  runs
}))
gcruns <- gcruns %>%
  mutate(
    center = (regstart + regend)/2,
    # get distance from center
    start_dist = ifelse(strand == "-",center - start,start - center),
    end_dist = ifelse(strand == "-",center - end,end - center),
    # get abs values of distance from the center
    distance = case_when(
      start_dist <= 0 & end_dist >= 0 ~ 0,
      start_dist > 0 ~ start_dist,
      end_dist < 0 ~ abs(end_dist) 
      ),
    acc = ifelse( values == 0, "Closed","Open")
  )
gcruns.gr <- GRanges(gcruns)
Sys.time() - st
# output
cgout <- file.path(subdir,"200731_gm_nanoNOMe_tss_1kb_singleread_cpg_calls.txt.gz")
gcout <- file.path(subdir,"200731_gm_nanoNOMe_tss_1kb_singleread_gc_runs.txt.gz")
write_tsv(cgcalls,cgout)
write_tsv(gcruns,gcout)
```

```{r read_data, eval = T, echo = F, fig.height=4, fig.width=4, message=F, warning = F,results = 'hide', fig.show = 'show'}
cgout <- file.path(subdir,"200731_gm_nanoNOMe_tss_1kb_singleread_cpg_calls.txt.gz")
gcout <- file.path(subdir,"200731_gm_nanoNOMe_tss_1kb_singleread_gc_runs.txt.gz")
cgcalls <- read_tsv(cgout)
gccalls <- read_tsv(gcout)
```

```{r cg_avgmeth, eval = T, echo = F, fig.height=6, fig.width=8, message=F, warning = F,results = 'hide', fig.show = 'show'}
# subset region - cpg only
cgside = 500
cpg_tss <- cgcalls[cgcalls$distance > -cgside & cgcalls$distance < cgside,]
cpg_avg <- cpg_tss %>%
  group_by(qname,txid,quartile) %>%
  filter(!is.na(mcall), mcall != -1) %>%
  summarize(mfreq = mean(mcall),
    n = n()) %>%
  mutate(mod = "cpg")
```
##### removing sub-nucleosome footprints

```{r remove_protein, eval = T, echo = F, fig.height=6, fig.width=8, message=F, warning = F,results = 'hide', fig.show = 'show'}
# just the runs within the gcside
gcside <- 100
gcruns_tss <- gcruns %>%
  mutate(regcenter = (regstart + regend)/2,
    start_dist = start - regcenter , end_dist = end - regcenter
  ) %>%
  filter((start_dist <= - gcside & end_dist >= - gcside) |
    (end_dist >= gcside & start_dist <= gcside) |
    (start_dist >= - gcside & end_dist <= gcside))
######################################################################
# getting average methylation from runs
######################################################################
# recombine and limit width to the region of interest
prot_model <- readRDS(file.path(subdir,"200317_gcruns_protein_binding_EM_model.rds")) 
gcruns_fixed  <- fix_protein_runs(gcruns_tss,prot_model)
gpc_avg <- gcruns_fixed %>%
  # need to change start/end according to distance and fix the width to match that
  mutate(start_dist = ifelse(start_dist < -gcside,-gcside,start_dist), 
    end_dist = ifelse(end_dist > gcside,gcside,end_dist),
    lengths = end_dist - start_dist)  %>%
  group_by(qname,txid,quartile) %>%
  summarize( meth = sum(lengths * values),
    n = sum(lengths),
    mfreq = meth/n) %>%
  dplyr::select(-meth) %>%
  mutate(mod = "gpc")

# add to the cpg and make the same conversion
meth_avg <- bind_rows(cpg_avg,gpc_avg) 
meth_avg.spread <- meth_avg %>%
  dplyr::select(-n) %>%
  spread(mod,mfreq) 
meth_avg.gather <- meth_avg.spread %>%
  ungroup() %>%
  gather(mod,mfreq,cpg,gpc) %>%
  mutate(exp = factor(quartile)) 
meth_avg_labs <- paste(meth_avg.spread$qname, meth_avg.spread$txid,sep="_")
```

```{r meth_avg_distro, eval = T, echo = F, fig.height=6, fig.width=8, message=F, warning = F,results = 'hide', fig.show = 'show'}
pal <- pal_npg("nrc")(10) 
exp_pal <- c(pal[4],pal[3],pal[1],pal[8])
# let's save data
out.tb <- meth_avg.gather
outpath <- file.path(plotdir,"200627_tss_meth_distro_test_data.tsv")
write_tsv(out.tb,outpath)

plotpath <- file.path(plotdir,"200627_tss_meth_distro_test.pdf")
pdf(plotpath, width = 5, height = 2)
ggplot(meth_avg.gather,aes( x = mfreq , fill = exp)) +
  facet_wrap(~mod, ncol = 2, scales = "free",  label = as_labeller(c(cpg = "CpG Methylation",gpc = "GpC Accessibility"))) +
  geom_density(alpha = 0.4) +
  coord_cartesian(clip = "off") +
  scale_fill_manual(name = "Expression\nQuartile",values = exp_pal) +
  labs( x = "TSS Region Per-Read Frequency", 
    y = "Density") +
  theme(legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"))
ggplot(meth_avg.gather,aes( x = mfreq , fill = exp)) +
  facet_wrap(~mod, ncol = 2, scales = "free",  label = as_labeller(c(cpg = "CpG Methylation",gpc = "GpC Accessibility"))) +
  geom_histogram(bins = 30, position = "dodge") +
  coord_cartesian(clip = "off") +
  labs( x = "TSS Region Per-Read Frequency", 
    y = "Density") +
  theme(legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"))
ggplot(meth_avg.gather,aes( x = mfreq )) +
  facet_wrap(~mod, ncol = 2, scales = "free",  label = as_labeller(c(cpg = "CpG Methylation",gpc = "GpC Accessibility"))) +
  geom_density(alpha = 0.4) +
  coord_cartesian(clip = "off") +
  scale_fill_manual(name = "Expression\nQuartile",values = exp_pal) +
  labs( x = "TSS Region Per-Read Frequency", 
    y = "Density") +
  theme(legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"))
dev.off()

qs <- quantile(regs.sub$gcnum,seq(0.2,1,0.2),na.rm = T)
plt <- gpc_avg 
plt$gcnum <- regs.sub$gcnum[match(plt$txid,regs.sub$txid)]
plt <- plt %>%
  ungroup() %>%
  filter(quartile %in% c(1,4)) %>%
  mutate(
    bin = case_when(
      gcnum <= qs[1] ~ names(qs)[1],
      gcnum <= qs[2] ~ names(qs)[2],
      gcnum <= qs[3] ~ names(qs)[3],
      gcnum <= qs[4] ~ names(qs)[4],
      TRUE ~ names(qs)[5]),
    bin = factor(bin,levels = names(qs)),
    exp = factor(quartile)
  ) 
# save into tsv
outpath <- file.path(plotdir,"200731_tss_meth_distro_gcdensity_test_data.tsv")
write_tsv(plt,outpath)
plt <- read_tsv(outpath) %>%
  mutate(exp = factor(exp))
nums <- plt %>%
  group_by(bin,exp) %>%
  distinct(txid) %>%
  summarize(n = n()) %>%
  mutate(
    nlab = paste("N =",n),
    y = ifelse( exp == 1,6,4.5))
plotpath <- file.path(plotdir,"200731_tss_meth_distro_gcdensity_test.pdf")
pdf(plotpath, width = 5, height = 4)
ggplot(plt,aes( x = mfreq, fill = exp)) +
  facet_wrap(~bin) +
  geom_density(alpha = 0.4) +
  coord_cartesian(clip = "off") +
  geom_text(data = nums, aes( label = nlab, y = y, color =exp), x = 1, hjust = 1, vjust = 1,size = 2.5)+
  scale_fill_manual(name = "Expression\nQuartile",values = exp_pal[c(1,4)]) +
  scale_color_manual(name = "Expression\nQuartile",values = exp_pal[c(1,4)]) +
  labs( x = "TSS Region Per-Read Frequency", 
    y = "Density") +
  theme(legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"),
    legend.position = "bottom"
  )
dev.off()

qs <- quantile(regs.sub$cgnum,seq(0.2,1,0.2),na.rm = T)
plt <- cpg_avg 
plt$cgnum <- regs.sub$cgnum[match(plt$txid,regs.sub$txid)]
plt <- plt %>%
  ungroup() %>%
  filter(quartile %in% c(1,4)) %>%
  mutate(
    bin = case_when(
      cgnum <= qs[1] ~ names(qs)[1],
      cgnum <= qs[2] ~ names(qs)[2],
      cgnum <= qs[3] ~ names(qs)[3],
      cgnum <= qs[4] ~ names(qs)[4],
      TRUE ~ names(qs)[5]),
    bin = factor(bin,levels = names(qs)),
    exp = factor(quartile)
  )  
nums <- plt %>%
  group_by(bin,exp) %>%
  distinct(qname) %>%
  summarize(n = n()) %>%
  mutate(
    nlab = paste("N =",n),
    y = ifelse( exp == 1,6,4.5))
# save into tsv
outpath <- file.path(plotdir,"200731_tss_meth_distro_cgdensity_test_data.tsv")
write_tsv(plt,outpath)
plt <- read_tsv(outpath)
plotpath <- file.path(plotdir,"200731_tss_meth_distro_cgdensity_test.pdf")
pdf(plotpath, width = 5, height = 4)
ggplot(plt,aes( x = mfreq, fill = exp)) +
  facet_wrap(~bin) +
  geom_density() +
  coord_cartesian(clip = "off") +
  geom_text(data = nums, aes( label = nlab, y = y, color =exp), x = 1, hjust = 1, vjust = 1,size = 2.5)+
  scale_fill_manual(name = "Expression\nQuartile",values = exp_pal[c(1,4)]) +
  scale_color_manual(name = "Expression\nQuartile",values = exp_pal[c(1,4)]) +
  labs( x = "TSS Region Per-Read Frequency", 
    y = "Density") +
  theme(legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"),
    legend.position = "bottom"
  )
dev.off()
```

#########################
# Heatmaps
#########################
Heatmap of gc runs
```{r closed_run_heatmap, eval = T, echo = F, fig.height=4, fig.width=4, message=F, warning = F,results = 'hide', fig.show = 'show'}
dists <- seq(-1000,1000,10)
runs.heat <- bind_rows(lapply(dists,function(d){
  x <- gcruns[gcruns$start_dist <= d & gcruns$end_dist >= d & gcruns$width <= 510,]
  y <- x %>%
    group_by(exp, width, values) %>%
    summarize(n = n())
  # roll mean along width for this distance
  bind_rows(lapply(seq(0,500),function(s){
      y[which(y$width >= s & y$width <= s + 10),] %>%
        group_by(exp,values) %>%
        summarize( n = sum(n)) %>%
        mutate(width = s)
    })) %>%
    mutate(d = d)
  }))
runs.heat <- runs.heat %>%
  mutate(acc = ifelse( values == 1, "Open","Closed"))
# normalize for each type,value, and distance and take every 5 loci
heat.group <- runs.heat %>%
  filter(width%%5 == 0) %>%
  group_by(exp,acc)
heat.list <- heat.group %>%
  group_split()
heat.norm <- bind_rows(lapply(heat.list,function(x){ 
    totn <- sum(x$n) 
    x$den <- x$n/totn
    x
  }))
```

```{r closed_run_heatmap_plot, eval = T, echo = F, fig.height=4, fig.width=4, message=F, warning = F,results = 'hide', fig.show = 'show'}
require(gridExtra)
heat_pal <- wes_palette("Zissou1")

plotpath <- file.path(plotdir,"200527_gm_tss_runs_heatmap.pdf")
pdf(plotpath,width = 7, height = 4, useDingbats = F)
g.closed.one <- ggplot(heat.norm %>% filter(acc == "Closed",exp == 1),aes( x = d, y = width, fill = den )) +
#  facet_wrap(~exp, ncol = 2, labeller = as_labeller(c(`1`="1st Quartile",`4`="4th Quartile"))) +
  lims(y = c(0,500)) +
  labs(title = "1st Quartile",x = "Distance From TSS", y = "Length of Closed Runs") +
  geom_bin2d(stat = "identity") +
  scale_fill_gradientn(name = "Density", colors = heat_pal) +
  theme(
    legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"),
    legend.title = element_text(size = 10), 
    legend.text = element_text(size = 10),
    plot.title = element_text(size = 10),
    panel.spacing = unit(1, "lines")
  ) 
g.closed.four <- ggplot(heat.norm %>% filter(acc == "Closed", exp == 4),aes( x = d, y = width, fill = den )) +
#  facet_wrap(~exp, ncol = 2, labeller = as_labeller(c(`1`="1st Quartile",`4`="4th Quartile"))) +
  lims(y = c(0,500)) +
  labs(title = "4th Quartile",x = "Distance From TSS", y = "Length of Closed Runs") +
  geom_bin2d(stat = "identity") +
  scale_fill_gradientn(name = "Density", colors = heat_pal) +
  theme(
    legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"),
    legend.title = element_text(size = 10), 
    legend.text = element_text(size = 10),
    plot.title = element_text(size = 10),
    panel.spacing = unit(1, "lines")
  ) 
g.open.one <- ggplot(heat.norm %>% filter(acc == "Open",exp == 1),aes( x = d, y = width, fill = den )) +
#  facet_wrap(~exp, ncol = 2, labeller = as_labeller(c(`1`="1st Quartile",`4`="4th Quartile"))) +
  lims(y = c(0,500)) +
  labs(title = "1st Quartile",x = "Distance From TSS", y = "Length of Open Runs") +
  geom_bin2d(stat = "identity") +
  scale_fill_gradientn(name = "Density", colors = heat_pal) +
  theme(
    legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"),
    legend.title = element_text(size = 10), 
    legend.text = element_text(size = 10),
    plot.title = element_text(size = 10),
    panel.spacing = unit(1, "lines")
  ) 
g.open.four <- ggplot(heat.norm %>% filter(acc == "Open",exp == 4),aes( x = d, y = width, fill = den )) +
#  facet_wrap(~exp, ncol = 2, labeller = as_labeller(c(`1`="1st Quartile",`4`="4th Quartile"))) +
  lims(y = c(0,500)) +
  labs(title = "4th Quartile",x = "Distance From TSS", y = "Length of Open Runs") +
  geom_bin2d(stat = "identity") +
  scale_fill_gradientn(name = "Density", colors = heat_pal) +
  theme(
    legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"),
    legend.title = element_text(size = 10), 
    legend.text = element_text(size = 10),
    plot.title = element_text(size = 10),
    panel.spacing = unit(1, "lines")
  ) 
# https://stackoverflow.com/questions/38444635/fixed-graph-size-in-ggplot2
gA = ggplotGrob(g.closed.one)
gB = ggplotGrob(g.open.one)
gC = ggplotGrob(g.closed.four)
gD = ggplotGrob(g.open.four)
gA$widths <- gB$widths <- gC$widths <- gD$widths
grid.arrange(gA, gB,gC,gD)
dev.off()
```
###########################################################
# EM clustering
###########################################################

Only use regions that have > 13 gc and > 17 cg in the 100bp window

```{r num_filter, eval = T, echo = F, fig.height=6, fig.width=8, message=F, warning = F,results = 'hide', fig.show = 'show'}
regs.sub <- regs.sub %>%
  filter(gcnum >= 14, cgnum >= 18)
cgcalls <- cgcalls[cgcalls$txid %in% regs.sub$txid,]
gcruns <- gcruns[gcruns$txid %in% regs.sub$txid,]
meth_avg <- meth_avg[meth_avg$txid %in% regs.sub$txid,]
meth_avg.spread <- meth_avg.spread[meth_avg.spread$txid %in% regs.sub$txid,] %>%
  na.omit()
sub.list <- list(regs = regs.sub, cg = cgcalls, gc = gcruns, avg = meth_avg, spread = meth_avg.spread)
outpath <- file.path(subdir,"200802_gm_tss_allgenes_cg_gc_filtered_list.rds")
saveRDS(sub.list,outpath)
```

```{r read_filtered, eval = T, echo = F, fig.height=6, fig.width=8, message=F, warning = F,results = 'hide', fig.show = 'show'}
# alternatively I can start from here
outpath <- file.path(subdir,"200802_gm_tss_allgenes_cg_gc_filtered_list.rds")
sub.list <- readRDS(outpath)
regs.sub <- sub.list$regs
cgcalls <- sub.list$cg
gcruns <- sub.list$gc
meth_avg <- sub.list$avg
meth_avg.spread <- sub.list$spread

```
#################################
# clustering
#################################


```{r em_clustering, eval = T, echo = F, fig.height=6, fig.width=8, message=F, warning = F,results = 'hide', fig.show = 'show'}
# thresholding
thr <- 0.9
cl.info <- tibble(
  cpg = rep(c(1,2),2),
  gpc = rep(c(1,2),each = 2),
  cgthr = ifelse(cpg == 1, thr,thr),
  gcthr = ifelse(gpc == 1, thr,thr),
  cluster = paste(cpg,gpc,sep="_"),
  cgstate = ifelse(cpg == 1, "Low CpG", "High CpG"),
  gcstate = ifelse(gpc == 1, "Low GpC", "High GpC"),
  lab = paste(cgstate,gcstate,sep = " ; ")
)

## per txid
meth.mat <- meth_avg.spread 
cpgmod <- Mclust(meth.mat$cpg, G = 2, modelNames = "V")
gpcmod <- Mclust(meth.mat %>% filter(gpc != 1, gpc !=0) %>% .$gpc, G = 2, modelNames = "V")
summary(cpgmod,parameters = T)
summary(gpcmod,parameters = T)
mods.list <- list(cpg = cpgmod,gpc = gpcmod)

# assign classification on all data
cpgpred <- predict(cpgmod,meth.mat$cpg)
gpcpred <- predict(gpcmod,meth.mat$gpc)

meth.cluster <- meth.mat %>%
  ungroup() %>%
  mutate( 
    cpg_cluster = factor(cpgpred$classification), 
    gpc_cluster = factor(gpcpred$classification),
    cluster = paste(cpg_cluster,gpc_cluster,sep="_")
  )
meth.cluster$cpg_prob <- sapply(seq(nrow(meth.cluster)),function(i)cpgpred$z[i,meth.cluster$cpg_cluster[i]])
meth.cluster$gpc_prob <- sapply(seq(nrow(meth.cluster)),function(i)gpcpred$z[i,meth.cluster$gpc_cluster[i]])
```

```{r cluster_exp, eval = T, echo = F, fig.height=6, fig.width=8, message=F, warning = F,results = 'hide', fig.show = 'show'}
meth.cluster <- meth.cluster %>%
  mutate(
    lab = cl.info$lab[match(cluster,cl.info$cluster)],
    cpg_sig = ifelse( cpg_prob >= cl.info$cgthr[match(lab,cl.info$lab)], "sig", "insig"),
    gpc_sig = ifelse( gpc_prob >= cl.info$gcthr[match(lab,cl.info$lab)], "sig", "insig"),
    sig = ifelse( cpg_sig == "sig"& gpc_sig == "sig", "sig", "insig"), 
    qlab = paste(qname,txid), 
    exp = factor(quartile)
  )

freq.cl <- meth.cluster %>%
  gather(mod,freq,cpg,gpc) %>%
  mutate(cluster = ifelse(mod == "cpg",cpg_cluster,gpc_cluster),
    cl = case_when(
      mod == "cpg" & cpg_sig == "sig" ~ as.character(cluster),
      mod == "gpc" & gpc_sig == "sig" ~ as.character(cluster),
      TRUE ~ "None"),
    cl = factor(cl)
  )

# combinatorial numbers
cluster.sum <- meth.cluster %>%
  filter(sig == "sig") %>%
  group_by(txid,cluster,exp) %>%
  summarize(n =n()) %>%
  spread(cluster,n) %>%
  replace(is.na(.),0) %>%
  mutate(total = `1_1`+`1_2`+`2_1`+`2_2`)  %>%
  gather(cluster, n, -txid,-exp,-total) %>%
  mutate(frac = n/total, 
    lab = cl.info$lab[match(cluster,cl.info$cluster)]) %>%
  filter(total > 20)
```

```{r em_clustering_test_plot, eval = T, echo = F, fig.height=6, fig.width=8, message=F, warning = F,results = 'hide', fig.show = 'show'}
plotpath <- file.path(plotdir,"200731_tss_meth_clustering_distro_test.pdf")
pdf(plotpath, height = 2, width = 5)
ggplot(freq.cl,aes( x = freq, color = cl)) +
  facet_wrap(~mod, ncol = 2, scales = "free",  label = as_labeller(c(cpg = "CpG Methylation",gpc = "GpC Accessibility"))) +
  coord_cartesian(clip = "off") +
  labs( x = "TSS Region Per-Read Frequency", 
    y = "Density") +
  theme(legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid")) +
  geom_density()
ggplot(freq.cl,aes( x = freq, fill = cl)) +
  facet_wrap(~mod, ncol = 2, scales = "free",  label = as_labeller(c(cpg = "CpG Methylation",gpc = "GpC Accessibility"))) +
  coord_cartesian(clip = "off") +
  labs( x = "TSS Region Per-Read Frequency", 
    y = "Count") +
  theme(legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid")) +
  geom_histogram(bins = 50)
dev.off()

```

```{r em_clustering_finalize, eval = T, echo = F, fig.height=6, fig.width=8, message=F, warning = F,results = 'hide', fig.show = 'show'}
mods.list <- list(cpg = cpgmod, gpc = gpcmod, info = cl.info)
modpath <- file.path(subdir,"200731_TSS_combinatorial_cluster_models.rds")
saveRDS(mods.list,modpath)

gc.sum <- meth.cluster %>%
  filter(sig == "sig") %>%
  group_by(txid,gpc_cluster,exp) %>%
  summarize(n =n()) %>%
  spread(gpc_cluster,n) %>%
  replace(is.na(.),0) %>%
  mutate(total = `1` + `2`, openfrac = `2`/total)
gc.sum %>%
  group_by(exp) %>%
  summarize( mean(openfrac), median(openfrac))
cg.sum <- meth.cluster %>%
  filter(sig == "sig") %>%
  group_by(txid,cpg_cluster,exp) %>%
  summarize(n =n()) %>%
  spread(cpg_cluster,n) %>%
  replace(is.na(.),0) %>%
  mutate(total = `1` + `2`, openfrac = `2`/total)
cg.sum %>%
  group_by(exp) %>%
  summarize( mean(openfrac), median(openfrac))
```

```{r em_cluster_plot, eval = T, echo = F, fig.height=4, fig.width=4, message=F, warning = F,results = 'hide', fig.show = 'show'}
pal <- pal_npg("nrc")(10)
four_pal <- c(pal[9],pal[1],pal[4],pal[3])

# numbers
sum.met <- cluster.sum %>%
  group_by(lab,exp) %>%
  summarize(
    regn = n(),
    totn = sum(n),
    `Fraction Q1`= round(quantile(frac,0.25),3),
    `Fraction Mean` = round(mean(frac),3),
    `Fraction Median` = round(median(frac),3),
    `Fraction Q3` = round(quantile(frac,0.75),3)) %>%
  arrange(lab,exp) %>%
  dplyr::rename(Cluster = lab, `Expression Quartile` = exp, `Total Reads` = totn, `Number of Genes` = regn)
# output the summary tabble
outpath <- file.path(plotdir,"200731_gm_exp_combinatorial_states_summary.tsv")
write_tsv(sum.met,outpath)

# output clustersum
out.tb <- cluster.sum
outpath <- file.path(plotdir,"200731_gm_exp_combinatorial_states_data.tsv")
write_tsv(out.tb,outpath)
plotpath <- file.path(plotdir,"200731_gm_exp_combinatorial_states.pdf")
meth.cluster$exp <- factor(meth.cluster$exp)
pdf(plotpath,width = 5, height = 2, useDingbats = F)
ggplot(cluster.sum,aes( color = lab, x = exp, y = frac)) +
  geom_boxplot(outlier.shape = NA)  +
  scale_color_manual(name = "Read State", values = four_pal) +
  labs(x = "Expression Quartile", y = "Fraction of Reads\nPer Region") + 
  theme(
    legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"),
    legend.title = element_text(size = 8), 
    legend.text = element_text(size = 7)) +
  coord_cartesian(clip = "off")
ggplot(cluster.sum,aes(fill = lab, x = frac, y = exp)) +
  geom_density_ridges(alpha = 0.5, scale = 1) +
  scale_fill_manual(name = "Read State", values = four_pal) +
  labs(y = "Expression Quartile", x = "Fraction of Reads Per Region") + 
  coord_cartesian(clip = "off")
ggplot(cluster.sum,aes(fill = exp, x = frac, y = lab)) +
  geom_density_ridges(alpha = 0.5, scale = 1) +
  scale_fill_manual(name = "Expression Quartile", values = four_pal) +
  labs(y = "Read State", x = "Fraction of Reads Per Region") + 
  coord_cartesian(clip = "off") 
ggplot(cluster.sum,aes(y = exp, x = frac, fill = lab)) +
  facet_wrap(~lab, scales = "free",nrow = 1) +
  geom_density_ridges(scale = 1.5) +
  lims( x = c(0,1)) +
  scale_fill_manual(name = "Read State", values = four_pal) +
  labs(y = "Read State", x = "Fraction of Reads Per Region") + 
  coord_cartesian(clip = "off") +
  scale_y_discrete(limits = rev(levels(factor(cluster.sum$exp)))) +
  theme(panel.spacing = unit(0.5,"lines"),
    legend.position = "bottom"
  )
ggplot(cluster.sum,aes(x = exp, y = frac, color = lab)) +
  facet_wrap(~lab, scales = "free",nrow = 1) +
  geom_boxplot(outlier.shape = NA) +
  scale_color_manual(name = "Read State", values = four_pal) +
  labs(x = "Expression Quartile", y = "Fraction of Reads Per Region") + 
  lims(y = c(0,1)) +
  coord_cartesian(clip = "off") +
  scale_x_discrete(limits = rev(levels(factor(cluster.sum$exp)))) +
  coord_flip() +
  theme(panel.spacing = unit(0.5,"lines"),
    legend.position = "bottom"
  )

dev.off()
```

```{r hisotne, eval = T, echo = F, fig.height=4, fig.width=4, message=F, warning = F,results = 'hide', fig.show = 'show'}
regs.gr <- GRanges(regs.sub)
################################################
# H3K4me3
################################################
annodir <- "/kyber/Data/Nanopore/projects/nanonome/analysis/data/gm12878"
h3k4me3_path <- file.path(annodir,"GM12878_H3K4me3_ChIP_peaks.bed.gz")
h3k4me3.peaks <- GRanges(read_tsv(h3k4me3_path,col_names = c("chrom","start","end")) )
# peak at tss?
k4ovl <- overlapsAny(regs.gr,h3k4me3.peaks)
################################################
# H3K27me3
################################################
h3k27me3_path <- file.path(annodir,"GM12878_H3K27me3_ChIP_peaks.bed.gz")
h3k27me3.peaks <- GRanges(read_tsv(h3k27me3_path,col_names = c("chrom","start","end")) )
k27ovl <- overlapsAny(regs.gr,h3k27me3.peaks)
# bivalent
biovl <- k4ovl & k27ovl

regs.sub$histone = "None"
regs.sub$histone[k4ovl] <- "H3K4me3"
regs.sub$histone[k27ovl] <- "H3K27me3"
regs.sub$histone[biovl] <- "Bivalent"
table(regs.sub$histone)
# summarize
meth.cluster <- meth.cluster %>%
  mutate(histone = regs.sub$histone[match(txid,regs.sub$txid)])
# combinatorial numbers
cluster.sum <- meth.cluster %>%
  filter(sig == "sig") %>%
  group_by(txid,cluster,histone) %>%
  summarize(n =n()) %>%
  spread(cluster,n) %>%
  replace(is.na(.),0) %>%
  mutate(total = `1_1`+`1_2`+`2_1`+`2_2`)  %>%
  gather(cluster, n, -txid,-histone,-total) %>%
  mutate(frac = n/total, 
    lab = cl.info$lab[match(cluster,cl.info$cluster)]) %>%
  filter(total > 20)
```

```{r histone_plot, eval = T, echo = F, fig.height=4, fig.width=4, message=F, warning = F,results = 'hide', fig.show = 'show'}
pal <- pal_npg("nrc")(10)
four_pal <- c(pal[9],pal[1],pal[4],pal[3])

# numbers
sum.met <- cluster.sum %>%
  group_by(lab,histone) %>%
  summarize(
    regn = n(),
    totn = sum(n),
    `Fraction Q1`= round(quantile(frac,0.25),3),
    `Fraction Mean` = round(mean(frac),3),
    `Fraction Median` = round(median(frac),3),
    `Fraction Q3` = round(quantile(frac,0.75),3)) %>%
  arrange(lab,histone) %>%
  dplyr::rename(Cluster = lab, `Histone Modification` = histone, `Total Reads` = totn, `Number of Genes` = regn)
# output the summary tabble
outpath <- file.path(plotdir,"200731_gm_histone_combinatorial_states_summary.tsv")
write_tsv(sum.met,outpath)

# output clustersum
out.tb <- cluster.sum
outpath <- file.path(plotdir,"200731_gm_histone_combinatorial_states_data.tsv")
write_tsv(out.tb,outpath)
plotpath <- file.path(plotdir,"200731_gm_histone_combinatorial_states.pdf")
pdf(plotpath,width = 5.5, height = 2, useDingbats = F)
ggplot(cluster.sum,aes( color = lab, x = histone, y = frac)) +
  geom_boxplot(outlier.shape = NA)  +
  scale_color_manual(name = "Read State", values = four_pal) +
  labs(x = "Histone Modification", y = "Fraction of Reads\nPer Region") + 
  theme(
    legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid"),
    legend.title = element_text(size = 8), 
    legend.text = element_text(size = 7)) +
  coord_cartesian(clip = "off")
ggplot(cluster.sum,aes(fill = lab, x = frac, y = histone)) +
  geom_density_ridges(alpha = 0.5, scale = 1) +
  scale_fill_manual(name = "Read State", values = four_pal) +
  labs(y = "Histone Modification", x = "Fraction of Reads Per Region") + 
  coord_cartesian(clip = "off")
ggplot(cluster.sum,aes(fill = histone, x = frac, y = lab)) +
  geom_density_ridges(alpha = 0.5, scale = 1) +
  scale_fill_manual(name = "Histone Modification", values = four_pal) +
  labs(y = "Read State", x = "Fraction of Reads Per Region") + 
  coord_cartesian(clip = "off") 
ggplot(cluster.sum,aes(y = histone, x = frac, fill = lab)) +
  facet_wrap(~lab, scales = "fixed",nrow = 1) +
  geom_density_ridges(scale = 1.5) +
  lims( x = c(0,1)) +
  scale_fill_manual(name = "Read State", values = four_pal) +
  labs(y = "Read State", x = "Fraction of Reads Per Region") + 
  coord_cartesian(clip = "off") +
#  scale_y_discrete(limits = rev(levels(factor(cluster.sum$exp)))) +
  theme(panel.spacing = unit(0.5,"lines"),
    legend.position = "bottom"
  )
ggplot(cluster.sum,aes(x = histone, y = frac, color = lab)) +
  facet_wrap(~lab, scales = "fixed",nrow = 1) +
  geom_boxplot(outlier.shape = NA) +
  scale_color_manual(name = "Read State", values = four_pal) +
  labs(x = "Histone Modification", y = "Fraction of Reads Per Region") + 
  lims(y = c(0,1)) +
  coord_cartesian(clip = "off") +
#  scale_x_discrete(limits = rev(levels(factor(cluster.sum$exp)))) +
  coord_flip() +
  theme(panel.spacing = unit(0.5,"lines"),
    legend.position = "bottom"
  )

dev.off()
```
##################################################################
# example region 
##################################################################
```{r singleread_plot, eval = T, echo = F, fig.height=6, fig.width=8, message=F, warning = F,results = 'hide', fig.show = 'show'}
txid <- regs.sub[which(regs.sub$hgnc == "NEXMIF"),]$txid
pal <- pal_npg("nrc")(10)
meth_pal <- c(pal[4],pal[5],pal[1],pal[2])

outpath <- file.path(subdir,"200402_tss_sub_clusters.rds")
meth.cluster <- readRDS(outpath)
meth.cluster <- meth.cluster %>%
  mutate(qlab = paste(qname,txid))

regidx <- which(regs.sub$txid == txid)
reg.sel <- regs.sub[regidx,]
cgcalls.sub <- cgcalls.dist[[regidx]] %>%
  filter(txid == txid) %>%
  mutate(qlab = paste(qname,reg.sel$txid))
gccalls.sub <- gccalls.dist[[regidx]] %>%
  filter(txid == txid) %>%
  mutate(qlab = paste(qname,reg.sel$txid))
cgruns.sel <- getRuns(cgcalls.sub,maxGap = 20) %>%
  mutate(qlab = paste(qname,reg.sel$txid))
gcruns.sel <- getRuns_fast(gccalls.sub) %>%
  mutate(qlab = paste(qname,reg.sel$txid))
# assign cluster
cgcalls.cl <- cgcalls.sub %>%
  mutate(cluster = meth.cluster$cluster[match(qlab,meth.cluster$qlab)]) %>%
  filter(!is.na(cluster)) %>%
  group_by(cluster) 
gccalls.cl <- gccalls.sub %>%
  mutate(cluster = meth.cluster$cluster[match(qlab,meth.cluster$qlab)]) %>%
  filter(!is.na(cluster)) %>%
  group_by(cluster) 
cgruns.sel <- cgruns.sel %>%
  mutate(cluster = meth.cluster$cluster[match(qlab,meth.cluster$qlab)]) %>%
  filter(!is.na(cluster)) %>%
  group_by(cluster) 
gcruns.sel <- gcruns.sel %>%
  mutate(cluster = meth.cluster$cluster[match(qlab,meth.cluster$qlab)]) %>%
  filter(!is.na(cluster)) %>%
  group_by(cluster)
# group by cluster and split
gcruns_sel.list <- gcruns.sel %>%
  group_split()
cgruns_sel.list <- cgruns.sel %>%
  group_split()
names(gcruns_sel.list) <- gcruns.sel %>% group_keys() %>% .$cluster
names(cgruns_sel.list) <- cgruns.sel %>% group_keys() %>% .$cluster
names(cgruns_sel.list) == names(gcruns_sel.list)
# order the reads
ofs <- 5
starti <- 0
cg_ordered.list <- list()
gc_ordered.list <- list()
for ( i in seq_along(cgruns_sel.list)) {
  cg_ordered.list[[i]] <- order_reads(cgruns_sel.list[[i]], offset = starti + ofs * i)
  gc_ordered.list[[i]] <- order_reads(gcruns_sel.list[[i]], bounds = cg_ordered.list[[i]]$bounds, offset = starti + ofs * i)
  starti <- starti + nrow(cg_ordered.list[[i]]$bounds)
}
cg_runs.ordered <- bind_rows(lapply(cg_ordered.list,function(y)y$x)) %>%
  mutate(values = factor(values))
cg_bounds.ordered <- bind_rows(lapply(cg_ordered.list,function(y)y$bounds))
gc_runs.ordered <- bind_rows(lapply(gc_ordered.list,function(y)y$x)) %>%
  mutate(values = factor(values))
gc_bounds.ordered <- bind_rows(lapply(gc_ordered.list,function(y)y$bounds))

runs_ordered <- bind_rows(list( cpg = cg_runs.ordered,gpc = gc_runs.ordered),.id = "mod")
# label the methylation states
runs_ordered <- runs_ordered %>%
  mutate(state = case_when(
      mod == "cpg" & values == 1 ~ "Methylated",
      mod == "cpg" & values == 0 ~ "Unmethylated",
      mod == "gpc" & values == 1 ~ "Accessible",
      mod == "gpc" & values == 0 ~ "Inaccessible"))
bounds_ordered <- bind_rows(list( cpg = cg_bounds.ordered,gpc = gc_bounds.ordered),.id = "mod")
# average profiles
cgfreq.cl <- cgcalls.cl %>%
  filter(!is.na(mcall)) %>%
  group_by(distance,cluster) %>%
  summarize(n = n(), freq = mean(mcall))
gcfreq.cl <- gccalls.cl %>%
  filter(!is.na(mcall), mcall != -1) %>%
  group_by(distance,cluster) %>%
  summarize(n = n(), freq = mean(mcall))
freq.cl <- bind_rows(list(cpg = cgfreq.cl,gpc = gcfreq.cl),.id = "mod")
# annotation
reg <- regs.sub[regs.sub$txid == txid,]
explevel <- reg$exp
reg <- as_tibble(trans.gr[match(reg$txid,trans.gr$txid)])
symbol <- reg$hgnc
txid <- reg$txid
ensid <- reg$ensembl_gene_id
#  exons <- getBM(attributes = c("exon_chrom_start",
#                                "exon_chrom_end",
#                                "ensembl_exon_id"),filters = 
#                   "ensembl_gene_id", values = ensid, mart = mart)
side <- 1e3
aspace <- side/4
if (reg$strand == "-"){
  xrange <- seq(reg$end,reg$start,-aspace)
} else{
  xrange <- seq(reg$start,reg$end,aspace)
}
if (length(xrange) == 1) {
  trans.range <- tibble(x = reg$start, xend = reg$end)
} else {
  trans.range <- tibble(x = xrange[1:length(xrange)-1],
                      xend = xrange[2:length(xrange)])
}
tss <- ifelse(reg$strand == "+",reg$start,reg$end)
labelx <- ifelse(reg$strand == "+",tss-aspace/5,tss+aspace/5)
just <- ifelse(reg$strand == "+","right","left")
label <- ifelse(symbol == "",txid,symbol)
maxy <- max(gc_runs.ordered$ymin)
miny <- min(gc_runs.ordered$ymin)
start <- tss - 1e3 #min(gc_runs.ordered$start)
end <- tss + 1e3 #max(gc_runs.ordered$end)
# windows
windows <- tibble(
  start = c(tss - 500, tss - 100),
  end =  c(tss + 500, tss + 100),
  mod = c("cpg","gpc")) 

g.both <- ggplot(runs_ordered,aes(xmin = start, xmax = end, ymin = ymin, ymax = ymax)) +
  facet_wrap(~mod, label = as_labeller(c(cpg = "CpG Methylation",gpc = "GpC Accessibility"))) +
  geom_rect(data = bounds_ordered, fill = "grey90") + 
  geom_rect(aes(fill = state))  +
  geom_rect(data = windows, mapping = aes( xmin = start, xmax = end, ymin = -Inf, ymax = Inf), 
    fill = "orange", color = "black", linetype = "dashed",size = 0.1,,alpha = 0.25) +
#    geom_vline(data = windows, mapping = aes( xintercept = pos ), linetype = "dashed",size = 0.1) + 
  scale_fill_manual(name = "State", values = meth_pal) +
  labs( x = "Coordinate", y = "Reads") +
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(),
    legend.background = element_rect(color = "black", fill = NA, size = 0.5, linetype = "solid")
  ) 
g.cgfreq <- ggplot(freq.cl %>% filter(mod == "cpg"),aes( x = distance, y = freq, color = mod)) +
  facet_wrap(~cluster,ncol = 2,scales = "free") +
  geom_vline(xintercept = 0, linetype = "longdash", size = 0.2) +
  annotate("text",x = labelx, y = 0.1, label = label, hjust = just) +
  geom_smooth(se = F,span = 0.5) +
  lims( x = c(-1000,1000), y = c(0,1))
g.gcfreq <- ggplot(freq.cl %>% filter(mod == "gpc"),aes( x = distance, y = freq, color = mod)) +
  facet_wrap(~cluster,ncol = 2,scales = "free") +
  geom_vline(xintercept = 0, linetype = "longdash", size = 0.2) +
  annotate("text",x = labelx, y = 0.1, label = label, hjust = just) +
  geom_smooth(se = F,span = 0.2) +
  lims( x = c(-1000,1000), y = c(0,1))
# add annotation
aoff <- 7
g.both <- g.both +
#    geom_rect(inherit.aes = F, data = exons, 
#              mapping = aes(xmin = exon_chrom_start, xmax = exon_chrom_end,
#                            ymin = 0.05, ymax = 0.15), fill = "black") +
  geom_segment(inherit.aes = F, data = trans.range,
               mapping = aes(x = x, xend = xend, y = miny - aoff, yend = miny - aoff),
               arrow = arrow(length = unit(0.1,"cm"))) +
  geom_vline(xintercept = tss, linetype = "longdash", size = 0.2) +
  annotate("text",x = labelx, y = miny -  aoff, label = label, hjust = just) +
  coord_cartesian( xlim = c(start,end), ylim = c(miny - aoff - 0.5,maxy))
plotpath <- file.path(plotdir,"200402_gm_tss_clusters_singleread_runs.pdf")
pdf(plotpath,width = 5, height = 2.5, useDingbats = F)
  print(g.both)
  print(g.cgfreq)
  print(g.gcfreq)
dev.off()
```

